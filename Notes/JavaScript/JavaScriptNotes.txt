                                                                                                <== Section1: Getting Started==>
JavaScript (js) is a light-weight object-oriented programming language which is used by several websites for scripting the webpages. It is an interpreted, full-fledged programming language that enables dynamic interactivity on websites when applied to an HTML document.
It was introduced in the year 1995 for adding programs to the webpages in the Netscape Navigator browser.

In web browsers, JavaScript consists of three main parts:

ECMAScript provides the core functionality.
The Document Object Model (DOM) provides interfaces for interacting with elements on web pages
The Browser Object Model (BOM) provides the browser API for interacting with the web browser.

Application of JavaScript
JavaScript is used to create interactive websites. It is mainly used for:

Client-side validation,
Dynamic drop-down menus,
Displaying date and time,
Displaying pop-up windows and dialog boxes (like an alert dialog box, confirm dialog box and prompt dialog box),
Displaying clocks etc.

To define a variable in JavaScript, you use var keyword. For example:
var x = 10;
var y = 20;

ES6 added a new way to declare a variable with the let keyword and its a good practice to use let keyword instead of var keyword:
let x = 10;
let y = 20;

To declare a function, you use the function keyword. The following example defines a function that calculates the sum of two arguments:

function add( a, b ) {
   return a + b;
}
To call the add() function, you use the following syntax:

let result = add(14, 99);
To log the result into the console window of the web browser, you use the console.log() :

console.log(result);  o/p-- 113

=>JavaScript provides 3 places to put the JavaScript code: within body tag, within head tag and external JavaScript file.

1.Between the head tag of html-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>JavaScript Hello World Example</title>
    <script>
        alert('Hello, World!');
    </script>
</head>
<body>
</body>
</html>

2.In .js file (external javaScript)-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>JavaScript Hello World Example</title>
    <script src="js/app.js"></script>
</head>
<body>

</body>
</html>

When you have multiple JavaScript files on a page, the JavaScript engine interprets the files in the order that they appear. For example:

<script src="js/service.js"></script>
<script src="js/app.js"></script>

In this example, JavaScript engine will interpret the service.js and the app.js files in sequence. It completes interpreting the service.js file first before interpreting the app.js file.

For the page that includes many external JavaScript files, the blank page is shown during the page rendering phase.

3.To avoid this, you include the JavaScript file just before the </body> tag as shown in this example:-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>JavaScript Hello World Example</title>
</head>
<body>
 
   <!-- end of page content here-->
   <script src="js/service.js"></script>
   <script src="js/app.js"></script>
</body>
</html>

To change how the browser load and execute JavaScript files, you use one of two attributes of the <script> element async and defer.

These attributes take effect only on the external script files. The async attribute instructs the web browser to execute the JavaScript file asynchronously. The async attribute does not guarantee the script files to execute in the order that they appear. For example:

<script async src="service.js"></script>
<script async src="app.js"></script>

The defer attribute requests the web browser to execute the script file after the HTML document has been parsed.

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>JavaScript defer demonstration</title>
    <script defer src="defer-script.js"></script>
</head>
<body>
</body>
</html>

Even though we place the <script> element in the <head> section, the script will wait for the browser to receive the closing tag <html> to start executing.

Summary
Use <script> element to include a JavaScript file in a HTML page.
The async attribute of the <script> element instructs the web browser to fetch the JavaScript file in parallel and then parse and execute as soon as the JavaScript file is available.
The defer attribute of the <script> element allows the web browser to execute the JavaScript file after the document has been parsed.


                                                                                                          <==Section 2: Fundamentals==>
Use whitespace including cariage return, space, newline, and tab to format the code. The JavaScript engine ignores the whitespace.
let formatted = true; if (formatted) {console.log('The code is easy to read');}
It’s is equivalent to the following code that uses whitespace. Hence, this code is much easy to read:

let formatted = true;

if (formatted) {
  console.log('The code is easy to read');
}
Note that JavaScript bundlers remove all whitespace from JavaScript files and put them into a single file for deployment. By doing this, JavaScript bundlers make the JavaScript code lighter and faster to load in the web browsers

Undefined vs. undeclared variables==>
It’s important to distinguish between undefined and undeclared variables.

An undefined variable is a variable that has been declared but has not been initialized with a value. For example:

let message;
console.log(message); // undefined

In this example, the message variable is declared but not initialized. Therefore, the message variable is undefined.

In contrast, an undeclared variable is a variable that has not been declared. For example:

console.log(counter);

Output:

console.log(counter);
            ^
ReferenceError: counter is not defined

Use the const keyword to define a readonly reference to a value.
const workday = 5;
workday = 2;
Error:
Uncaught TypeError: Assignment to constant variable.

JavaScript has the primitive data types:==>

null
undefined
boolean
number
string
symbol – available from ES2015
bigint – available from ES2020
and a complex data type object.

JavaScript is a dynamically typed language. It means that a variable doesn’t associate with a type. In other words, a variable can hold a value of different types. For example:

let counter = 120; // counter is a number
counter = false;   // counter is now a boolean
counter = "foo";   // counter is now a string

To get the current type of the value that the variable stores, you use the typeof operator:
let counter = 120;
console.log(typeof(counter)); // "number"

counter = false; 
console.log(typeof(counter)); // "boolean"

counter = "Hi";
console.log(typeof(counter)); // "string"
Output:
"number"
"boolean"
"string"

The undefined type==>
The undefined type is a primitive type that has only one value undefined. By default, when a variable is declared but not initialized, it is assigned the value of undefined.
Consider Example--
let counter;
console.log(counter);        // undefined
console.log(typeof counter); // undefined

The null type==>
The null type is the second primitive data type that also has only one value null. For example:

let obj = null;
console.log(typeof obj); // object

The typeof null returns object is a known bug in JavaScript. A proposal to fix this was proposed but rejected. The reason was the that fix would break a lot of existing sites.

JavaScript defines that null is equal to undefined as follows:

console.log(null == undefined); // true

The number type==>
JavaScript uses the number type to represent both integer and floating-point numbers.
The following statement declares a variable and initializes its value with an integer:

let num = 100;
To represent a floating-point number, you include a decimal point followed by at least one number. For example:
let price= 12.5; 
let discount = 0.05;

NaN==>
NaN stands for Not a Number. It is a special numeric value that indicates an invalid number. For example, the division of a string by a number returns NaN:.

console.log('a'/2); // NaN;
The NaN has two special characteristics:

Any operation with NaN returns NaN.
The NaN does not equal any value, including itself.
Here are some examples:

console.log(NaN/2); // NaN
console.log(NaN == NaN); // false

The string type==>
A string that begins with a double quote must end with a double quote. Likewise, a string that begins with a single quote must also end with a single quote:

let greeting = 'Hi';
let message  = "Bye";
JavaScript strings are immutable. This means that it cannot be modified once created. However, you can create a new string from an existing string. For example:

let str = 'JavaScript';
str = str + ' String';

The boolean type==>
The boolean type has two literal values: true and false in lowercase. The following example declares two variables that hold the boolean values.

let inProgress = true;
let completed = false;

JavaScript allows values of other types to be converted into boolean values of true or false.

To convert a value of another data type into a boolean value, you use the Boolean() function. The following table shows the conversion rules:

Type	true	                                        false
string	non-empty string	                       empty string
number	non-zero number and Infinity	0,    NaN
object	non-null object	                        null
undefined	 	                        undefined

console.log(typeof completed); // boolean

String Methods==>

1.The search() method accepts a regular expression and returns the index of the first match in a string:

let index = str.search(regexp);
In this syntax, the regexp is a regular expression. If you pass a non-RegExp into the method, it will convert that value to a RegExp.
If the search() doesn’t find any match, it returns -1.
i
example--to search first capital letter
let re = /[A-Z]/;
let str = 'hi There! How are you?';
let index = str.search(re);

console.log(index);
Output:3

2.indexOf()-The indexOf() returns the index of the first occurrence of a substring in a string, or -1 if the string does not contain the substring.
The indexOf() is case-sensitive.
The following example uses the indexOf() to get the index of the first occurrence of the substring 'str' in the string 'finding substring in string':

let str = 'finding substring in string';
let index = str.indexOf('str');

console.log(index); // 11

) Using indexOf() to count occurrences of a substring in a string
The following example uses the indexOf() method to count the number of occurrences of the substring 'know' in the string 'You do not know what you do not know until you know.':

let str = 'You do not know what you do not know until you know.';
let substr = 'know';

let count = 0;

let index = str.indexOf(substr);
while(index !== -1) {
    count++;
    index = str.indexOf(substr, index + 1);
}

console.log(count);

How it works:

First, use the indexOf() method to find the first occurrence of the substr in the str.
Then, use the while loop to repeatedly find the next position of the substr in the str starting from the last found position + 1.
 The indexOf() and case-sensitivity
The indexOf() is case-sensitive. See the following example:

let str = 'JS indexOf';
let substr = 'js';

let index = str.indexOf(substr);

console.log(index); // -1

In this example, the indexOf() returns -1 because the string JS IndexOf does not contain the substring js but JS.

To perform a case-insensitive search for the index of a substring within a string, you can convert both substring and string to lowercase before using the indexOf() method as follows:

let str = 'JS indexOf';
let substr = 'js';

let index = str.toLocaleLowerCase().indexOf(substr.toLocaleLowerCase());

console.log(index); // 0
Code language: JavaScript (javascript)

3.-The lastIndexOf() returns the index of the last occurrence of a substring in a string, or -1 if the string does not contain the substring. It searches for the substring backward from the end of the string or from the fromIndex if this argument is available.
str.lastIndexOf(substr, [, fromIndex]);
This example uses the lastIndexOf() method to locate the last occurrence of the substring 'a' in the string 'JavaScript':
let str = 'JavaScript';
let index = str.lastIndexOf('a');
console.log(index);
Output:3

If you pass the fromIndex argument to the string, the lastIndexOf() method will start searching backward from the fromIndex as shown in the following example:

let str = 'JavaScript';
let index = str.lastIndexOf('a',2);
console.log(index);
Output:1
The lastIndexOf() and case-sensitivity
The lastIndexOf() is case-sensitive. The following example returns -1:
let str = 'Hello, World!';
let substr = 'L';
let index = str.lastIndexOf(substr);
console.log(index); // -1

To perform a case-insensitive search for the index of the last occurrence of a substring within a string, you can convert both substring and string to lowercase before applying the lastIndexOf() method as follows:
let str = 'Hello, World!';
let substr = 'L';
let index = str.toLocaleLowerCase().lastIndexOf(substr.toLocaleLowerCase());
console.log(index); // -1

4.The includes() method determines whether a string contains another string:
string.includes(searchString [,position])
The includes() method returns true if the searchString found in the string; otherwise false.
let str = 'JavaScript String';
console.log(str.includes('script'));
Output:false

The following example uses the includes() method with the second parameter:

let str = 'JavaScript String';
console.log(str.includes('Script', 5));
Output:
false
5.The startsWith() returns true if a string starts with a substring or false otherwise.

The following shows the syntax of the startsWith() method:

String.startsWith(searchString [,position])
Arguments
searchString is the characters to be searched for at the start of this string.
position is an optional parameter that determines the start position to search for the searchString. It defaults to 0.
const title = 'Jack and Jill Went Up the Hill';
Code language: JavaScript (javascript)
The following example uses the startsWith() method to check if the title starts with the string 'Jack':
console.log(title.startsWith('Jack'));
Output:true
6.The endsWith() returns true if a string ends with the characters of a specified string or false otherwise.

Here’s the syntax of the endsWith() method:

String.endsWith(searchString [,length])
Arguments
searchString is the characters to be searched for at the end of the string.
length is an optional parameter that determines the length of the string to search. It defaults to the length of the string.
Note that to check if a string starts with a substring, you use the startsWith() method.

JavaScript String endsWith() method examples
Suppose that you have a string called title:
const title = 'Jack and Jill Went Up the Hill';
The following example uses the endsWith() method to check if the title ends with the string 'Hill':
console.log(title.endsWith('Hill'));
Output:true

7.Use the trim() to remove whitespace characters from both ends of a string.
let resultString = str.trim();
let str = '  JS trim  ';
let result = str.trim();
console.log(result);
Output:"JS trim"

8.To remove the whitespace characters from the beginning of a string, you use the trimStart() method:
let newString = originalString.trimStart();
const str = '   JavaScript   ';
const result = str.trimStart();

console.log({ str });
console.log({ result });
Code language: JavaScript (javascript)
Output:
{ str: '   JavaScript   ' }
{ result: 'JavaScript   ' }

9.To remove the whitespace characters from the end of a string, you use the trimEnd() method:
let newString = originalString.trimEnd();
const str = '   JavaScript   ';
const result = str.trimEnd();

console.log({ str });
console.log({ result });
Code language: JavaScript (javascript)
Output:{ str: '   JavaScript   ' }
{ result: '   JavaScript' }

9.Split--Use the JavaScript String split() to divide a string into an array of substrings by a separator.
Use the second parameter (limit) to return a limited number of splits.
split([separator, [,limit]]);
e split() accepts two optional parameters: separator and limit.

1) separator
The separator determines where each split should occur in the original string. The separator can be a string. Or it can be a regular expression.

If you omit the separator or the split() cannot find the separator in the string, the split() returns the entire string.

2) limit
The limit is zero or positive integer that specifies the number of substrings. The split() method will stop when the number of substrings equals to the limit.

If the limit is zero, the split() returns an empty array. If the limit is 1, the split() returns an array that contains the string.
The following example uses the split() method to split the string into words:

let str = 'JavaScript String split()';
let substrings = str.split(' ');
console.log(substrings);
Output:
["JavaScript", "String", "split()"]
 Returning a limited number of substrings example
The following example uses the split() method to divide a string into substrings using the space separator. It also uses the second parameter to limit the number of substrings to two:

let str = 'JavaScript String split()';
let substrings = str.split(' ',2);
console.log(substrings);
op:["JavaScript", "String"]
3) Splitting a string using a regular expression example
The following example uses the split() method to split sentences in a paragraph into sentences:

let paragraph = 'Good Morning! How are you? This is John. John is my friend.';
let sentences = paragraph.split(/[!,?,.]/);
console.log(sentences);
Output:
["Good Morning", " How are you", " This is John", " John is my friend", ""]
10.The JavaScript substring() returns the substring from a string between the start and end indexes.
The substring() method accepts two parameters: startIndexand endIndex:

The startIndex specifies the index of the first character to include in the returned substring.
The endIndex determines the first character to exclude from the returned substring. In other words, the returned substring doesn’t include the character at the endIndex.
If you omit the endIndex, the substring() returns the substring to the end of the string.

If startIndex equals endIndex, the substring() method returns an empty string.

If startIndex is greater than the endIndex, the substring() swaps their roles: the startIndex becomes the endIndex and vice versa.

If either startIndex or endIndex is less than zero or greater than the string.length, the substring() considers it as zero (0) or string.length respectively.

If any parameter is NaN, the substring() treats it as if it were zero (0).
ExampleThe following example uses the substring method to extract a substring starting from the beginning of the string:

let str = 'JavaScript Substring';
let substring = str.substring(0,10);
console.log(substring);
Output:
JavaScript
2) Extracting a substring to the end of the string example
The following example uses the substring() to extract a substring from the index 11 to the end of the string:

let str = 'JavaScript Substring';
let substring = str.substring(11);

console.log(substring);
Output:
Substring
11.Use the JavaScript String slice() method to extract a substring from a string.
slice(start, end)
const str = 'Hello';
const substr = str.slice(3);
console.log({ substr });
Output:
{ substr: 'lo' }
If the start is negative, the slice() method starts extraction from the str.length + start. For example:
const str = 'Hello';
const substr = str.slice(-3);
console.log({ substr });
Output:
{ substr: 'llo' }
12.The JavaScript String replace() method returns a new string with a substring (substr) replaced by a new one (newSubstr).

Note that the replace() method doesn’t change the original string. It returns a new string.
let newStr = str.replace(substr, newSubstr);
The following example uses the replace() to replace the JS in the string 'JS will, JS will rock you' wit the new substring JavaScript:

let str = 'JS will, JS will rock you!';
let newStr = str.replace('JS','JavaScript');

console.log(newStr);
Output:
JavaScript will, JS will rock you!

13.Use the JavaScript string replaceAll() method to replace all occurrences of a substring with a new one in a string.
1) Simple JavaScriptString replaceAll() example
The following example uses the String replaceAll() method to replace the string JS with the string JavaScript in the string ‘JS will, JS will, JS will rock you':

let str = 'JS will, JS will, JS will rock you.';
let newStr = str.replaceAll('JS','JavaScript');

console.log(newStr);
Output:
JavaScript will, JavaScript will, JavaScript will rock you. 


The symbol type==>
JavaScript added a primitive type in ES6: the symbol. Different from other primitive types, the symbol type does not have a literal form.

To create a symbol, you call the Symbol function as follows:

let s1 = Symbol();

The bigint type ==>
The bigint type represents the whole numbers that are larger than 253 – 1. To form a bigint literal number, you append the letter n at the end of the number:

let pageView = 9007199254740991n;
console.log(typeof(pageView)); // 'bigint'

The object type==>
In JavaScript, an object is a collection of properties, where each property is defined as a key-value pair.

The following example defines an empty object using the object literal syntax:

let emptyObject = {};

The following example defines the person object with two properties: firstName and lastName.

let person = {
    firstName: 'John',
    lastName: 'Doe'
};

A property name of an object can be any string. You can use quotes around the property name if it is not a valid identifier.

For example, if the person object has a property first-name, you must place it in the quotes such as "first-name".

A property of an object can hold an object. For example:

let contact = {
    firstName: 'John',
    lastName: 'Doe',
    email: 'john.doe@example.com',
    phone: '(408)-555-9999',
    address: {
        building: '4000',
        street: 'North 1st street',
        city: 'San Jose',
        state: 'CA',
        country: 'USA'
    }
}

The contact object has the firstName, lastName, email, phone, and address properties.

The address property itself holds an object that has building,  street, city, state, and country properties.

To access a object’s property, you can use

The dot notation (.)
The array-like notation ([]).
The following example uses the dot notation (.) to access the firstName and lastName properties of the contact object.

console.log(contact.firstName);
console.log(contact.lastName);

If you reference a property that does not exist, you’ll get an undefined value. For example:

console.log(contact.age); // undefined

The following example uses the array-like notation to access the email and phone properties of the contact object.

console.log(contact['phone']); // '(408)-555-9999'
console.log(contact['email']); // 'john.doe@example.com'

==>JavaScript allows the values of other types to be cast to boolean values. To cast a non-Boolean value to a boolean value, you use the built-in Boolean() function. For example:

let error = 'An error occurred';
let hasError = Boolean(error);
console.log(hasError);

Output:
true

How it works.

First, declare a variable error that holds a literal string 'An error occurred'.
Second, cast the error variable to a boolean value using the Boolean() function.
Third, output the value of the hasError variable to the console.
Because the error variable holds a non-empty string, the Boolean() function casts its value to true.

==>ES6 introduced template literals that allow you to define a string backtick (`) characters:

let name = `John`';

The template literals allow you to use the single quotes and double quotes inside a string without the need of escaping them. For example:

let mesage = `"I'm good". She said";

Also, you can place the variables and expressions inside a template literal. JavaScript will replace the variables with their value in the string. This is called string interpolation. For example:

let name = 'John';
let message = `Hi, I'm ${name}.`;

console.log(message);
Output:

Hi, I'm John.
In this example, JavaScript replaces the name variable with its value inside the template literal.

Getting the length of the string
The length property returns the length of a string:

let str = "Good Morning!";
console.log(str.length);  // 13

Accessing characters
To access the characters in a string, you use the array-like [] notation with the zero-based index. The following example returns the first character of a string with the index zero:

let str = "Hello";
console.log(str[0]); // "H"

To access the last character of the string, you use the length - 1 index:

let str = "Hello";
console.log(str[str.length -1]); // "o"

Concatenating strings via + operator
To concatenate two or more strings, you use the + operator:

let name = 'John';
let str = 'Hello ' + name;

console.log(str); // "Hello John"


==>Modifying the value of a property
To change the value of a property, you use the assignment operator (=). For example:

let person = {
    firstName: 'John',
    lastName: 'Doe'
};

person.firstName = 'Jane';

console.log(person);

Output:

{ firstName: 'Jane', lastName: 'Doe' }

==>Adding a new property to an object
Unlike objects in other programming languages such as Java and C#, you can add a property to an object after object creation.

The following statement adds the age property to the person object and assigns 25 to it:

person.age = 25;
==>Deleting a property of an object
To delete a property of an object, you use the delete operator:

delete objectName.propertyName;

The following example removes the age property from the person object:

delete person.age;

If you attempt to reaccess the age property, you’ll get an undefined value

==>Checking if a property exists
To check if a property exists in an object, you use the in operator:

propertyName in objectName
The in operator returns true if the propertyName exists in the objectName.

The following example creates an employee object and uses the in operator to check if the ssn and employeeId properties exist in the object:

let employee = {
    firstName: 'Peter',
    lastName: 'Doe',
    employeeId: 1
};

console.log('ssn' in employee);
console.log('employeeId' in employee);

Output:

false
true


Stack and heap memory==>
When you declare variables, the JavaScript engine allocates the memory for them on two memory locations: stack and heap.
Static data is the data whose size is fixed at compile time. Static data includes:

Primitive values (null, undefined, boolean, number, string, symbol, and BigInt)
Reference values that refer to objects.
Because static data has a size that does not change, the JavaScript engine allocates a fixed amount of memory space to the static data and store it on the stack.

For example, the following declares two variables and initializes their values to a literal string and a number:

let name = 'John';
let age = 25;

Because name and age are primitive values, the JavaScript engine stores these variables on the stack as shown in the follow

Note that strings are objects in many programming languages, including Java and C#. However, strings are primitive values in JavaScript.

Unlike the stack, JavaScript stores objects (and functions) on the heap. The JavaScript engine doesn’t allocate a fixed amount of memory for these objects. Instead, it’ll allocate more space as needed.

The following example defines the name, age, and person variables:

let name = 'John';
let age = 25;

let person = {
  name: 'John',
  age: 25,
};

Internally,JavaScript allocates memory on the stack for the three variables name, age, and person.

The JavaScript engine creates a new object on the heap memory. Also, it links the person variable on the stack memory to the object on the heap memory.

Because of this, we say that the person variable is a reference that refers to an object.

Dynamic properties
A reference value allows you to add, change, or delete properties at any time. For example:

let person = {
  name: 'John',
  age: 25,
};

// add the ssn property
person.ssn = '123-45-6789';

// change the name
person.name = 'John Doe';

// delete the age property
delete person.age;


console.log(person);

Output:

{ name: 'John Doe', ssn: '123-45-6789' }

Unlike a reference value, a primitive value cannot have properties. This means that you cannot add a property to a primitive value.

JavaScript allows you to add a property to a primitive value. However, it won’t take any effect. For example:

let name = 'John';
name.alias = 'Knight';

console.log(name.alias); // undefined
Code language: JavaScript (javascript)
Output:

undefined
Code language: JavaScript (javascript)
In this example, we add the alias property to the name primitive value. But when we access the alias property via the name primitive value, it returns undefined.

Summary
Javascript has two types of values: primitive values and reference values.
You can add, change, or delete properties to a reference value, whereas you cannot do it with a primitive value.
Copying a primitive value from one variable to another creates a separate value copy. It means that changing the value in one variable does not affect the other.for Example --let age = 25;
let newAge = age;

newAge = newAge + 1;
console.log(age, newAge);

Copying a reference from one variable to another creates a reference so that two variables refer to the same object. This means that changing the object via one variable reflects in another variable. for Example
let person = {
  name: 'John',
  age: 25,
};
let member = person;
member.age = 26;
console.log(person);
console.log(member);

Introduction to JavaScript arrays==>
In JavaScript, an array is an ordered list of values. Each value is called an element specified by an index.
A JavaScript array has the following characteristics:
First, an array can hold values of mixed types. For example, you can have an array that stores elements with the types number, string, boolean, and null.
Second, the size of an array is dynamic and auto-growing. In other words, you don’t need to specify the array size up front.

let athletes = new Array(3); // creates an array with initial size 3
let scores = new Array(1, 2, 3); // create an array with three numbers 1,2 3
let signs = new Array('Red'); // creates an array with one element 'Red'

The more preferred way to create an array is to use the array literal notation:

let arrayName = [element1, element2, element3, ...];
The array literal form uses the square brackets [] to wrap a comma-separated list of elements.

The following example creates the colors array that holds string elements:

let colors = ['red', 'green', 'blue'];
To create an empty array, you use square brackets without specifying any element like this:

let emptyArray = [];
Accessing JavaScript array elements--
let mountains = ['Everest', 'Fuji', 'Nanga Parbat'];

console.log(mountains[0]); // 'Everest'
console.log(mountains[1]); // 'Fuji'
console.log(mountains[2]); // 'Nanga Parbat'

let mountains = ['Everest', 'Fuji', 'Nanga Parbat'];
mountains[2] = 'K2';

console.log(mountains);
Output:

[ 'Everest', 'Fuji', 'K2' ]
Getting the array size
Typically, the length property of an array returns the number of elements. The following example shows how to use the length property:

let mountains = ['Everest', 'Fuji', 'Nanga Parbat'];
console.log(mountains.length); // 3

1) Adding an element to the end of an array
To add an element to the end of an array, you use the push() method:

let seas = ['Black Sea', 'Caribbean Sea', 'North Sea', 'Baltic Sea'];
seas.push('Red Sea');
console.log(seas); 

Output:
[ 'Black Sea', 'Caribbean Sea', 'North Sea', 'Baltic Sea', 'Red Sea' ]

2) Adding an element to the beginning of an array
To add an element to the beginning of an array, you use the unshift() method:

let seas = ['Black Sea', 'Caribbean Sea', 'North Sea', 'Baltic Sea'];
seas.unshift('Red Sea');
console.log(seas);
Output:

[ 'Red Sea', 'Black Sea', 'Caribbean Sea', 'North Sea', 'Baltic Sea' ]
3) Removing an element from the end of an array
To remove an element from the end of an array, you use the pop() method:

let seas = ['Black Sea', 'Caribbean Sea', 'North Sea', 'Baltic Sea'];
const lastElement = seas.pop();
console.log(lastElement); 
Output:

Baltic Sea
4) Removing an element from the beginning of an array
To remove an element from the beginning of an array, you use the shift() method:

let seas = ['Black Sea', 'Caribbean Sea', 'North Sea', 'Baltic Sea'];
const firstElement = seas.shift();
console.log(firstElement);
Output:
Black Sea

5) Finding an index of an element in the array
To find the index of an element, you use the indexOf() method:

let seas = ['Black Sea', 'Caribbean Sea', 'North Sea', 'Baltic Sea'];
let index = seas.indexOf('North Sea');

console.log(index); // 2
Code language: JavaScript (javascript)
6) Check if a value is an array
To check if a value is an array, you use Array.isArray() method:

console.log(Array.isArray(seas)); // true
7)To  delete elements in an array, you pass two arguments into the splice() method as follows:

Array.splice(position,num);
Code language: JavaScript (javascript)
The position specifies the position of the first item to delete and the num argument determines the number of elements to delete.

The splice() method changes the original array and returns an array that contains the deleted elements.
let scores = [1, 2, 3, 4, 5];
The following statement deletes three elements of the scores array starting from the first element.
let deletedScores = scores.splice(0, 3);
The scores array now contains two elements.
console.log(scores); //  [4, 5]
And the deletedScores array contains three elements.
console.log(deletedScores); // [1, 2, 3]

You can insert one or more elements into an array by passing three or more arguments to the splice() method with the second argument is zero.
let colors = ['red', 'green', 'blue'];
The following statement inserts one element after the second element.

colors.splice(2, 0, 'purple');
The colors array now has four elements with the new element inserted in the second position.

console.log(colors); // ["red", "green", "purple", "blue"]

The splice() method allows you to insert new elements into an array while deleting existing elements simultaneously.
let languages = ['C', 'C++', 'Java', 'JavaScript'];
languages.splice(1, 1, 'Python');
Code language: JavaScript (javascript)
The languages array now still has four elements with the new second argument is 'Python' instead of 'C++'.
console.log(languages); 
// ["C", "Python", "Java", "JavaScript"]

7)The slice() returns a new array that contains the elements of the original array. It’s important to keep in mind that the slice() method performs the shallow copy of elements to the new array only. In addition, it doesn’t change the source array.
var numbers = [1,2,3,4,5];
var newNumbers = numbers.slice();
Code language: JavaScript (javascript)
In this example, the newNumbers array contains all the elements of the numbers array.
The typical use of the slice() method is to copy a portion of an array without modifying the source array. Here is an example:
var colors = ['red','green','blue','yellow','purple'];
var rgb = colors.slice(0,3);
console.log(rgb); // ["red", "green", "blue"]
Code language: JavaScript (javascript)

8)flat() method that creates a new array with all the elements of the subarrays concatenated to it recursively up to a specified depth.
The following shows the syntax of the flat() method:

let newArray = arrayObject.flat([depth])
Code language: JavaScript (javascript)
The depth parameter specifies how deep the method flats the array structure. It defaults to 1.

The following example shows how to flat an array of numbers:

const numbers = [1, 2, [3, 4, 5]];
const flatNumbers = numbers.flat();

console.log(flatNumbers);
Code language: JavaScript (javascript)
Output:

[1, 2, 3, 4, 5]
Code language: JSON / JSON with Comments (json)
In this example, we didn’t pass the depth argument into the flat() method therefore the depth is 1 by default. The flat() method concatenated all the elements of the nested array [3,4,5] to the elements of the new array.

Note that the flat() method creates a new array and doesn’t change the original array:

console.log(numbers);
Code language: JavaScript (javascript)
Output:

[ 1, 2, [ 3, 4, 5 ] ]
Code language: JavaScript (javascript)
The following example flats an array with two level depth:

const numbers = [1, 2, [3, 4, 5, [6, 7]]];
const flatNumbers = numbers.flat(2);

console.log(flatNumbers);
Output:
[1, 2, 3, 4, 5, 6, 7]
When you don’t know the depth level, you can pass the Infinity into the flat() method to recursively concatenate all elements of the sub-arrays into the new array:

const numbers = [1, 2, [3, 4, 5, [6, 7, [8, 9]]]];
const flatNumbers = numbers.flat(Infinity);

console.log(flatNumbers);
If an array has empty slots, you can use the flat() method to remove the holes, like this:

const numbers = [1, 2, , 4, , 5];
const sequence = numbers.flat();

console.log(sequence);
Output:
[ 1, 2, 4, 5 ]

JavaScript Operators: An arithmetic operator accepts numerical values as operands and returns a single numerical value. The numerical values can be literals or variables.
1) Arithrmatic operator-
=>Addition	+ let sum = 10 + 20;
console.log(sum); // 30

let x = '10',
    y = '20';
let result = x + y;  op -->1020
let result = 10 + '20';
console.log(result);  1020

let x = '10',
    y = 20;
let result = x + y;  op -->1020
let result = 10 + '20';
console.log(result);  1020

=>Subtraction  - 
let result = 30 - 10 or '30'-10 or 30-'10' or '30'-'10'
console.log(result); // 20
If a value is a string, a boolean, null, or undefined, the JavaScript engine will:
First, convert the value to a number using the Number() function.
Second, perform the subtraction.

=>Multiplication *
let result = 2 * 3;
console.log(result);
Code language: JavaScript (javascript)
Output:6
If either value is not a number, the JavaScript engine implicitly converts it into a number using the Number() function and performs the multiplication. For example:
let result = '5' * 2;
console.log(result);//10
=>Division /
let result = 20 / 10;
console.log(result); // 2
If either value is not a number, the JavaScript engine converts it into a number for division. For example:
let result = '20' / 2;
console.log(result); // 10;

Remainder Operator=>
1) Using the remainder operator with positive dividend example
The following example shows how to use the remainder operator with a positive dividend:
let remainder = 5 % -2;
console.log(remainder); // 1
remainder = 5 % 2;
console.log(remainder); // 1
2) Using the remainder operator with negative dividend example
The following example uses the remainder operator with a negative dividend:
let remainder = -5 % 3;
console.log(remainder); // -2
remainder = -5 % -3;
console.log(remainder); // -2
3) Using the remainder operator special values
If a dividend is an Infinity and a divisor is a finite number, the remainder is NaN. For example:
let remainder = Infinity % 2;
console.log(remainder); // NaN
Code language: JavaScript (javascript)
If a dividend is a finite number and a divisor is zero, the remainder is NaN:

let remainder = 10 % 0;
console.log(remainder); // NaN
If both dividend and divisor are Infinity, the remainder is NaN:

let remainder = Infinity % Infinity;
console.log(remainder); // NaN
If a dividend is a finite number and the divisor is an Infinity, the remainder is the dividend. For example:

let remainder = 10 % Infinity;
console.log(remainder); // 10
If the dividend is zero and the divisor is non-zero, the remainder is zero:

let remainder = 0 % 10;
console.log(remainder); // 0
If either dividend or divisor is not a number, it’s converted to a number using the Number() function and applied the above rules. For example:
let remainder = '10' % 3;
console.log(remainder); // 1

Assignment Operator=>
let a=10;

Strict equal (===) and not strict equal (!==)=>
The strict equal and not strict equal operators behave like the equal and not equal operators except that they don’t convert the operand before comparison. See the following example:
console.log("10" == 10); // true
console.log("10" === 10); // false
In the first comparison, since we use the equality operator, JavaScript converts the string into the number and performs the comparison.
However, in the second comparison, we use the strict equal operator ( ===), JavaScript doesn’t convert the string before comparison, therefore the result is false.
JavaScript exponentiation operator
To raise a number to the power of an exponent, you often use the static method Math.pow() with the following syntax:

Math.pow(base, exponent)
For example:

let result = Math.pow(2,2);
console.log(result); // 4

result = Math.pow(2,3);
console.log(result); // 8
Code language: JavaScript (javascript)
ECMAScript 2016 provided an alternative way to get a base to the exponent power by using the exponentiation operator ( **) with the following syntax:

x**n
The operator ** raises the x to the power of an exponent n.

Note that some languages use the caret symbol ^ for exponentiation. However, JavaScript already uses that symbol for the bitwise logical XOR operator.

The following example illustrates how to use the exponentiation operator (**):

let result = 2 ** 2;
console.log(result); // 4

result = 2 ** 3;
console.log(result); // 8

The Math.pow() accepts a value and converts it to a value of the number type for calculation. Similarly, the operator ** accept values of the number type. In addition, the operator ** accepts a value of the bigint type. For example:

let result = 2n ** 3n;
console.log(result); // 8n

let age = 18;
let message;
message = age >= 16 ? 'You can drive.' : 'You cannot drive.';
console.log(message);
Here’s the syntax of the ternary operator:
condition ? expressionIfTrue : expressionIfFalse

comma operator
JavaScript uses a comma (,) to represent the comma operator. A comma operator takes two expressions, evaluates them from left to right, and returns the value of the right expression.

Here’s the syntax of the comma operator:

leftExpression, rightExpression
For example:

let result = (10, 10 + 20);
console.log(result);
Output:

30
In this example, the 10, 10+20 returns the value of the right expression, which is 10+20. Therefore, the result value is 30.

See the following example:

let x = 10;
let y = (x++, x + 1);

console.log(x, y);
Code language: JavaScript (javascript)
Output:

11 12
In this example, we increase the value of x by one (x++), add one to x (x+1) and assign x to y. Therefore, x is 11, and y is 12 after the statement.

However, to make the code more explicit, you can use two statements rather than one statement with a comma operator like this:

let x = 10;
x++;
let y = x + 1;
console.log(x, y);
                                                   <==Section 3==>
Functions=>Use the function keyword to declare a function.
Use the functionName() to call a function.
The arguments variable is an array-like object inside a function, representing function arguments.
The function hoisting allows you to call a function before declaring it.
All functions implicitly return undefined if they don’t explicitly return a value.
Use the return statement to return a value from a function explicitly.lets see example
function say(message) {
    console.log(message);
}

let result = say('Hello');
console.log('Result:', result);
Code language: JavaScript (javascript)
Output:

Hello
Result: undefined
 in order to avoid this--
function say(message) {
    return message
}
let result = say('Hello');
console.log('Result:', result);
op=>Result: Hello

The following example uses multiple return statements in a function to return different values based on conditions:

function compare(a, b) {
    if (a > b) {
        return -1;
    } else if (a < b) {
        return 1;
    }
    return 0;
}
Code language: JavaScript (javascript)
The compare() function compares two values. It returns:

-1 if the first argument is greater than the second one.
1 if the first argument is less than the second one.
0 if  the first argument equals the second one

The arguments object==>The arguments object behaves like an array though it is not an instance of the Array type.
For example, you can use the square bracket [] to access the arguments: arguments[0] returns the first argument, arguments[1] returns the second one, and so on.
Also, you can use the length property of the arguments object to determine the number of arguments.
function add() {
    let sum = 0;
    for (let i = 0; i < arguments.length; i++) {
        sum += arguments[i];
    }
    return sum;
}
Hence, you can pass any number of arguments to the add() function, like this:

console.log(add(1, 2)); // 3
console.log(add(1, 2, 3, 4, 5)); // 15

Function hoisting
In JavaScript, you can use a function before declaring it. For example:

showMe(); // a hoisting example

function showMe(){
    console.log('an hoisting example');
}
This feature is called hoisting.
Function hoisting is a mechanism that the JavaScript engine physically moves function declarations to the top of the code before executing them.

Passing a function to another function=>

function add(a,b){
    return a+b;
}
let sum=add;  // the sum variable will have the reference of add function 
function average(a,b,fn){
    return fn(a,b)/2;
}
let result=average(55,85,sum) // here sum is the third argument fn of average function
console.log(result)

anonymous functions==>
An anonymous function is a function without a name.
(function () {
   //...
}); 
eg1.let show = function() {
    console.log('Anonymous function');
};
show();
Using anonymous functions as arguments=>
setTimeout(function() {
    console.log('Execute later after 1 second')
}, 1000);

Immediately invoked function execution(IIFE)=>
If you want to create a function and execute it immediately after the declaration, you can declare an anonymous function like this:
(function() {
    console.log('IIFE');
})();

let person = {
    firstName: 'John',
    lastName: 'Doe'
};

(function () {
    console.log(person.firstName + ' ' + person.lastName);
})(person);

Arrow functions
ES6 introduced arrow function expressions that provide a shorthand for declaring anonymous functions:

For example, this function:

let show = function () {
    console.log('Anonymous function');
};

… can be shortened using the following arrow function:

let show = () => console.log('Anonymous function')
Similarly, the following anonymous function:
let add = function (a, b) {
    return a + b;
};
… is functionally equivalent to the following arrow function:

let add = (a, b) => a + b;   

JavaScript pass-by-value==>In JavaScript, all function arguments are always passed by value. It means that JavaScript copies the values of the variables into the function arguments.which means the changes made to the arguments are not reflected outside of the function.

function square(x) {
    x = x * x;
    return x;
}
let y = 10;
let result = square(y);
console.log(result); // 100 
console.log(y); // 10 -- no change
If JavaScript used the pass-by-reference, the variable y would change to 100 after calling the function.

Pass-by-value of reference values
It’s not obvious to see that reference values are also passed by values. For example:

let person = {
  name: 'John',
  age: 25,
};
function increaseAge(obj) {
  obj.age += 1;
}
increaseAge(person);
console.log(person);

when passing an object to a function, you are passing the reference of that object, not the actual object. Therefore, the function can modify the properties of the object via its reference.

However, you cannot change the reference passed into the function. For example:

let person = {
  name: 'John',
  age: 25,
};

function increaseAge(obj) {
  obj.age += 1;

  // reference another object
  obj = { name: 'Jane', age: 22 };
}

increaseAge(person);

console.log(person);
Code language: JavaScript (javascript)
Output:

{ name: 'John', age: 26 }

JavaScript object methods==>
An object is a collection of key/value pairs or properties. When the value is a function, the property becomes a method. When a function is a property of an object, it becomes a method.
let person = {
    firstName: 'John',
    lastName: 'Doe',
    greet() {
        console.log('Hello, World!');
    }
};

person.greet();  //Hello, World!

Typically, methods need to access other properties of the object. so for that purpose use this keyword
let person = {
    firstName: 'John',
    lastName: 'Doe',
    greet() {
        console.log('Hello, World!');
    },
    getFullName(){
        return this.firstName+" "+this.lastName;
    }
};

person.greet();
console.log(person.getFullName());

ES6 class declaration=>
ES6 introduced a new syntax for declaring a class as shown in this example:

class Person {
    constructor(name) {
        this.name = name;
    }
    getName() {
        return this.name;
    }
}
let john=new Person("Vinay yadav");
let name=john.getName();  //Vinay yadav





